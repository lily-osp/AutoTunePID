# 1. System Architecture

## Introduction

This document outlines the internal software architecture of the `AutoTunePID` Arduino library. The library is designed as a self-contained C++ class (`AutoTunePID`) that encapsulates all the necessary logic for PID control, auto-tuning, signal processing, and system stability management.

## Core Components

The library architecture is centered around the `AutoTunePID` class, which integrates several key functional modules:

1.  **PID Controller Core:**
    *   Calculates the Proportional (P), Integral (I), and Derivative (D) terms based on the error between the setpoint and the current input.
    *   Combines these terms to produce a control output.
    *   Manages state variables like `_error`, `_previousError`, `_integral`, and `_derivative`.
    *   Operates at a fixed interval (default 100ms) managed via `millis()` for consistent timing.
    *   Supports `Normal` and `Reverse` modes by adjusting the error calculation.

2.  **Auto-Tuning Module:**
    *   Activated when `OperationalMode` is set to `Tune`.
    *   Implements relay feedback (oscillation) to determine the system's Ultimate Gain (`Ku`) and Oscillation Period (`Tu`).
    *   Supports different oscillation amplitudes (`Normal`, `Half`, `Mild`) via `OscillationMode`.
    *   Calculates PID gains (`_kp`, `_ki`, `_kd`) based on the selected `TuningMethod` (Ziegler-Nichols, Cohen-Coon, IMC, Tyreus-Luyben, Lambda Tuning) using the derived `Ku` and `Tu`.
    *   Relies on internal parameters like `_processTimeConstant` and `_deadTime` derived during tuning for some methods.

3.  **Signal Filtering Module:**
    *   Provides optional input and output filtering using Exponential Moving Average (EMA).
    *   Enabled/disabled via `enableInputFilter()` and `enableOutputFilter()`.
    *   Filter responsiveness (`alpha`) is configurable.
    *   Uses helper function `computeFilteredValue()` for EMA calculation.

4.  **Anti-Windup Module:**
    *   Prevents excessive integral term accumulation when the controller output is saturated (`_minOutput` or `_maxOutput`).
    *   Enabled/disabled via `enableAntiWindup()`.
    *   Clamps the `_integral` term based on a configurable `_integralWindupThreshold`.

5.  **System Corrector Module:**
    *   Monitors system stability by analyzing recent input data points stored in `_dataPoints`.
    *   Enabled/disabled via `enableCorrector()`.
    *   Detects potential instability based on input fluctuations exceeding `_stabilityThreshold`.
    *   Applies corrective actions like resetting the integral term, reducing output, or potentially triggering a re-tune if persistent instability is detected.

6.  **Configuration Management:**
    *   Provides public methods (setters like `setSetpoint`, `setTuningMethod`, `setOperationalMode`, etc.) to configure the controller's behavior.
    *   Stores configuration parameters as private member variables (`_setpoint`, `_method`, `_operationalMode`, etc.).
    *   Uses enumerations (`TuningMethod`, `OperationalMode`, `OscillationMode`) for clarity and type safety.

7.  **State Management (Operational Modes):**
    *   Manages the controller's overall state (`Normal`, `Reverse`, `Hold`, `Preserve`, `Tune`, `Auto`).
    *   Different modes alter the behavior of the `update()` method (e.g., skipping calculations in `Hold`, performing tuning in `Tune`).

## Data Flow

1.  **Input:** `update(currentInput)` receives the process variable.
2.  **Input Filtering (Optional):** `currentInput` is filtered if `_inputFilterEnabled` is true.
3.  **Error Calculation:** `_error = _setpoint - _input` (or `_input - _setpoint` in `Reverse` mode).
4.  **Corrector (Optional):** Input data is stored. If instability detected, corrective action is taken.
5.  **Tuning (If `Tune` Mode):** `performAutoTune()` runs instead of PID calculation. It manipulates `_output` to induce oscillations and calculate `Ku`/`Tu`, then computes gains.
6.  **PID Calculation (If Not `Tune`/`Hold`):**
    *   Integral term `_integral` is updated.
    *   Derivative term `_derivative` is calculated.
    *   `computePID()` calculates the raw `_output` based on `_kp`, `_ki`, `_kd`, `_error`, `_integral`, `_derivative`.
7.  **Anti-Windup (Optional):** `applyAntiWindup()` clamps `_integral` if `_output` was saturated and anti-windup is enabled.
8.  **Output Clamping:** `_output` is constrained between `_minOutput` and `_maxOutput`.
9.  **Output Filtering (Optional):** `_output` is filtered if `_outputFilterEnabled` is true.
10. **Output Retrieval:** `getOutput()` returns the final processed output value.

## Interaction with Arduino Environment

*   Uses `Arduino.h` for basic types and functions (`millis()`, `constrain()`, `abs()`).
*   Relies on the standard Arduino `new` and `delete[]` for dynamic memory allocation (for `_dataPoints` in the corrector).
*   Assumes periodic calls to its `update()` method from the main Arduino `loop()`.
