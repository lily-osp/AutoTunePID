# 4. Hardware Design

## Introduction

The `AutoTunePID` library is a software component designed to run on Arduino-compatible microcontrollers. While the library itself is hardware-agnostic, its effective use depends on a properly configured physical system consisting of a sensor, an actuator, and the microcontroller running the PID logic. This document outlines the general hardware considerations.

## Microcontroller Requirements

*   **Platform:** Any Arduino-compatible board (e.g., Arduino Uno, Nano, Mega, ESP32, ESP8266, etc.) that supports standard C++ and the Arduino core libraries (`Arduino.h`).
*   **Memory:** The library has a relatively small memory footprint (estimated ~40 bytes per instance plus memory for the corrector's data buffer if enabled). Ensure the target microcontroller has sufficient RAM.
*   **Processing Power:** PID calculations are generally lightweight. Auto-tuning involves more state but is temporary. Most Arduino boards are sufficient. Performance depends on the `update()` frequency and complexity of other tasks in the `loop()`.
*   **Timers:** The library uses `millis()` for timing the update interval and auto-tuning oscillations. No specific hardware timers are directly manipulated by the library itself.

## Sensor Requirements

*   **Type:** Any sensor that measures the process variable (PV) you want to control (e.g., temperature sensor like LM35/DHT22, rotational encoder for speed, photoresistor for light level, pressure sensor, flow meter).
*   **Interface:** The sensor must interface with the Arduino board. This typically involves:
    *   **Analog Input:** For sensors providing a voltage proportional to the measurement (e.g., connect to pins `A0`, `A1`, etc.). The `analogRead()` function would be used in the Arduino sketch to get the input value.
    *   **Digital Input:** For sensors providing digital signals (e.g., encoders, simple on/off sensors). Custom code might be needed in the sketch to interpret the signal (e.g., pulse counting).
    *   **Communication Bus:** For sensors using I2C, SPI, or UART. Requires appropriate libraries (e.g., `Wire.h`, `SPI.h`) in the sketch to communicate with the sensor.
*   **Resolution and Noise:** The quality of the sensor output directly impacts control performance. Noisy sensors may benefit from the library's input filtering feature (`enableInputFilter`).

## Actuator Requirements

*   **Type:** Any device that can influence the process variable based on the controller's output signal (e.g., heating element, motor, valve, LED, pump).
*   **Interface:** The actuator must be controllable by the Arduino board. Common interfaces include:
    *   **PWM Output:** For actuators like motors (via H-bridge/driver), heaters (via MOSFET/relay with PWM), LEDs. The `analogWrite()` function is typically used to send the PID output. The library's `minOutput` and `maxOutput` often correspond to the PWM range (e.g., 0-255 for standard Arduino PWM).
    *   **Digital Output:** For simple on/off control (e.g., relays). The PID output might be thresholded in the sketch to switch the digital pin (`digitalWrite()`).
    *   **Servo Control:** Using the `Servo` library, mapping the PID output range to servo angles.
    *   **Communication Bus:** Controlling smart actuators via I2C, SPI, UART, etc.
*   **Power:** The actuator often requires a separate power supply, controlled via a suitable driver circuit (e.g., MOSFET, relay, motor driver) connected to the Arduino's output pin. The Arduino pin typically cannot power the actuator directly.

## System Considerations

*   **Controllability:** The chosen actuator must have a demonstrable effect on the sensor reading.
*   **Response Time & Dead Time:** The system's dynamic characteristics (how quickly it responds, delays) influence PID tuning. The auto-tuning methods aim to identify these characteristics (`Tu`, `Ku`).
*   **Linearity:** PID control works best on systems that are reasonably linear around the operating point. Highly non-linear systems might require gain scheduling or more advanced control techniques beyond this library.
*   **Wiring:** Ensure correct and secure wiring between the microcontroller, sensor, actuator, and power supplies. Poor connections can lead to noise or failure.

## Example Conceptual Setup (Temperature Control)

1.  **Microcontroller:** Arduino Uno
2.  **Sensor:** LM35 Temperature Sensor connected to `A0`.
3.  **Actuator:** Heating Element controlled by a MOSFET.
4.  **Interface:** MOSFET Gate connected to a PWM pin (e.g., `D9`).
5.  **PID:** `AutoTunePID pid(0, 255, ...)` maps output to PWM range.
6.  **Sketch Logic:** `float temp = analogRead(A0) * conversion_factor; pid.update(temp); analogWrite(HEATER_PIN, pid.getOutput());`
