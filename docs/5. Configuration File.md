# 5. Configuration File

## Introduction

The `AutoTunePID` library is configured programmatically within your Arduino sketch (`.ino` file) rather than through external configuration files (like `.ini` or `.yaml`) commonly found in desktop or server applications. This approach is typical for embedded systems and Arduino libraries, integrating configuration directly into the application code.

This document details the various parameters and settings that can be configured using the library's constructor and public methods.

## Configuration Methods

Configuration is primarily achieved through:

1.  **Constructor:** Initial essential parameters are set when creating an `AutoTunePID` object.
2.  **Setter Methods:** Various public methods allow modification of parameters after initialization.

## Configuration Parameters

### 1. Core PID Setup (Constructor & Setters)

*   **Output Range (`minOutput`, `maxOutput`):**
    *   Set via: Constructor `AutoTunePID(minOutput, maxOutput, ...)`
    *   Description: Defines the lower and upper bounds of the controller's output value. This should match the range expected by your actuator control mechanism (e.g., 0-255 for Arduino PWM).
*   **Tuning Method (`method`):**
    *   Set via: Constructor `AutoTunePID(..., TuningMethod method)` or `setTuningMethod(TuningMethod method)`
    *   Description: Selects the algorithm used for auto-tuning or indicates manual gain setting.
    *   Values: `TuningMethod::ZieglerNichols` (default), `TuningMethod::CohenCoon`, `TuningMethod::IMC`, `TuningMethod::TyreusLuyben`, `TuningMethod::LambdaTuning`, `TuningMethod::Manual`.
*   **Setpoint (`setpoint`):**
    *   Set via: `setSetpoint(float setpoint)`
    *   Description: The target value for the process variable that the controller aims to achieve.
*   **Manual Gains (`kp`, `ki`, `kd`):**
    *   Set via: `setManualGains(float kp, float ki, float kd)`
    *   Description: Directly sets the Proportional, Integral, and Derivative gains. Typically used when `TuningMethod` is `Manual` or to override auto-tuned values.

### 2. Auto-Tuning Configuration

*   **Operational Mode (`mode`):**
    *   Set via: `setOperationalMode(OperationalMode mode)`
    *   Description: Controls the overall state of the controller. Setting to `OperationalMode::Tune` initiates the auto-tuning process.
    *   Values: `OperationalMode::Normal`, `OperationalMode::Reverse`, `OperationalMode::Hold`, `OperationalMode::Preserve`, `OperationalMode::Tune`, `OperationalMode::Auto`.
*   **Oscillation Mode (`mode`):**
    *   Set via: `setOscillationMode(OscillationMode mode)`
    *   Description: Determines the amplitude of the output oscillations used during the relay feedback phase of auto-tuning.
    *   Values: `OscillationMode::Normal`, `OscillationMode::Half`, `OscillationMode::Mild`.
*   **Oscillation Steps (`steps`):**
    *   Set via: `setOscillationSteps(int steps)`
    *   Description: Sets the number of output toggles (half-cycles) used to determine the oscillation period (`Tu`) during auto-tuning. More steps can improve accuracy but take longer. Default values depend on `OscillationMode`.
*   **Lambda (`lambda`):**
    *   Set via: `setLambda(float lambda)`
    *   Description: The tuning parameter ('Î»') used specifically for the `TuningMethod::LambdaTuning` and `TuningMethod::IMC` methods. It influences the trade-off between responsiveness and robustness.

### 3. Signal Processing Configuration

*   **Input Filter (`alpha`):**
    *   Set via: `enableInputFilter(float alpha)`
    *   Description: Enables Exponential Moving Average (EMA) filtering on the input signal. `alpha` controls smoothness (0.01=max smoothing, 1.0=no smoothing).
*   **Output Filter (`alpha`):**
    *   Set via: `enableOutputFilter(float alpha)`
    *   Description: Enables EMA filtering on the controller's output signal. `alpha` controls smoothness.

### 4. Control Enhancement Configuration

*   **Anti-Windup (`enable`, `threshold`):**
    *   Set via: `enableAntiWindup(bool enable, float threshold = 0.8f)`
    *   Description: Enables/disables the anti-windup mechanism. The `threshold` (as a fraction of the output range, default 0.8 or 80%) determines how close the output needs to be to saturation before anti-windup engages by clamping the integral term.
*   **Corrector (`enable`, `dataWindowSize`, `stabilityThreshold`):**
    *   Set via: `enableCorrector(bool enable, int dataWindowSize = 10, float stabilityThreshold = 0.1f)`
    *   Description: Enables/disables the system stability corrector. `dataWindowSize` sets the number of recent input samples to analyze. `stabilityThreshold` defines the level of fluctuation considered unstable.

## Development-Time Configuration Files

While there are no runtime configuration files, two files configure aspects of the library for the development environment:

*   **`library.properties`:** Standard Arduino library metadata file. Configures how the library appears in the Arduino IDE Library Manager (name, version, author, category, etc.).
*   **`keywords.txt`:** Defines syntax highlighting for the library's classes, methods, and constants within the Arduino IDE, improving code readability.

## Example Configuration in Sketch

```cpp
#include <AutoTunePID.h>

// Configure via Constructor: Output 0-255, use ZieglerNichols
AutoTunePID pid(0, 255, TuningMethod::ZieglerNichols);

void setup() {
  // Configure via Setters:
  pid.setSetpoint(50.0);                   // Target 50 degrees
  pid.enableInputFilter(0.1);              // Smooth noisy sensor input
  pid.enableAntiWindup(true, 0.9);         // Enable anti-windup at 90% saturation
  pid.setOscillationMode(OscillationMode::Mild); // Use mild oscillations for tuning
  pid.enableCorrector(true, 15, 0.05);     // Enable corrector, window 15, threshold 0.05

  // Start auto-tuning process
  pid.setOperationalMode(OperationalMode::Tune);
}

void loop() {
  float input = readSensor();
  pid.update(input);
  int outputValue = (int)pid.getOutput(); // Cast if needed
  analogWrite(ACTUATOR_PIN, outputValue);

  // After tuning, the mode automatically switches (usually to Normal).
  // You might want to manually switch modes if needed:
  // if (pid.getOperationalMode() != OperationalMode::Normal && digitalRead(TUNING_BUTTON) == LOW) {
  //   pid.setOperationalMode(OperationalMode::Normal);
  // }
}
